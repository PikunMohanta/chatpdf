{
  "document_id": "e4e1b562-644b-4f5e-89a2-3a085263107f",
  "chunks": [
    "TEAM MEMBERS: \n \n \n \nNAME \n \nRegistration No. \n \nGOURAV SWAIN \n \n20010454 \n \nOM PRAKASH MOHANTA \n \n20010448 \n \nADITYA SAUMYA \n \n20010473 \n \nSONALI RAJ \n \n20010456 \n \nABHILIPSHA SAHOO \n \n20010445 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n \n \nContent: \n \nDeclaration \nAcknowledgement \nAbstract \nIntroduction \nProblem Statement \nObjective Of The Gaming System \nStrategy/Algorithm Used In Code \nDFS Algorithm \nPseudocode \nSource Code \nOutput \nConclusion",
    "Declaration \n \n \n \n \nI hereby declare that the project work entitled “Tic-tac-toe \ngame using DFS algorithm” submitted to the CV Raman \nGlobal University, is a record of an original work done by our \nteam under the guidance of Prof. Santosh Sharma Sir. \n \n \n \n \n \n \n \n \n \n \nNAME OF THE STUDENTS \nGourav Swain   \nOm Prakash Mohanta \nAditya Saumya \nSonali Raj  \nAbhilipsha Sahoo",
    "ACKNOWLEDGEMENT \n \nFirstly, we would like to thank our professor \nSantosh Sharma Sir for giving us this opportunity to express our views \non this project. And also thank him for continuous guidance, \nmonitoring, and constant encouragement throughout this project. \n \nWe are thankful to those who have helped us throughout our \nproject work. \n \nLastly, we thank all our group members for finalizing this \nproject within a limited time frame, without whom this \nproject would not be possible.",
    "Abstract \nLearning to the program cobly be analogous to acquiring \nexpertise in abstract mathematics, which may be boring \nordulljority of students. Thus, among the countless options to \napproach learning coding , acquiring conceps through game \ncreation could pe the most enriching experience for students. \nConsequently, it is important to select a lucid and familiar \ngame for students. Then, the following step is to choose a \nlanguage that introduces the basic concepts of Depth First",
    "Search(DFS). For this paper, we chose the game of Tic-Tac-\nToe, which is straight-forward for most people. The \nprogramming language chosen here is C. \nThis report is an introduction to the Tic Tac Toe game in C \nprogramming. Anybody, who doesn’t know even the basics of \nTic Tac Toe in C ,will be certainly able to understand and gain \nthe great knowledge from this report.The core theme of the \nreport focuses on the developmentof Tic Tac Toe game in C \nlanguage.",
    "language.",
    "Introduction : \nThe Tic Tac Toe game is a game for two players, called \"X\" and \"O\", who take \nturns marking the spaces in a 3×3 grid. The player who succeeded in placing \nthree respective marks in a horizontal, vertical, or diagonal row wins the game. \nThe Tic Tac Toe is a great way to pass your free time whether you're standing in \na line or spending time with your kids. Stop wasting paper and save trees. \nBecause of the simplicity of Tic Tac Toe, it is often used as a pedagogical tool",
    "for teaching the concepts of good sportsmanship and the branch of artificial \nintelligence. \nDepth-first search is an algorithm for traversing or searching tree or graph data \nstructures. The algorithm starts at the root node (selecting some arbitrary node \nas the root node in the case of a graph) and explores as far as possible along \neach branch before backtracking. So the basic idea is to start from the root or \nany arbitrary node and mark the node and move to the adjacent unmarked",
    "node and continue this loop until there is no unmarked adjacent node. Then \nbacktrack and check for other unmarked nodes and traverse them. Finally, print \nthe nodes in the path. \nTic-tac-toe is not a very challenging game for human beings. If you’re an \nenthusiast, you’ve probably moved from the basic game to some variant like \nthree dimensional tic-tac-toe on a larger grid. If you sit downright now to play \nordinary three-by-three tic-tac-toe witha friend, what will probably happen is",
    "that every gamewill come out a tie. Both you and your friend can probably play \nperfectly, never making a mistake thatwould allow your opponent to win. But \ncan you describehow you know where to move each turn? Most of thetime, you \nprobably aren’t even aware of alternative possibilities; you just look at the \nboard and instantly knowwhere you want to move. That kind of instant \nknowledgeis great for human beings, because it makes you a fast player. But it",
    "isn’t much help in writing a computer program. \nThe tic-tac-toe game is played on a 3x3 grid the game is played by two players, \nwho take turns. The first player marks moves with a circle, the second with a \ncross. The player who has formed a horizontal, vertical, or diag-onal sequence \nof three marks wins.",
    "Problem Statement: \nSince the 1970s, people started to take interest in using their \ncomputers as an entertainment environment, thus, the multi \nbillion game industry was starting to take shape. Having presented \nearlier the sum of money this industry produces, I decided to have \na go and create a game of my own. As a kid, I was always \nfascinated by the idea of becoming a game developer, but, as \nyearswent by, I have realized this is not exactly what programming",
    "and computer science, as a practice,are about and I dropped the \nidea. However, the third year project offered me the possibility to \ntry and achieve one of my childhood’s dreams and I couldn’t resist \nthe temptation \n \nObjectives Of The Gaming System: \nThe game is developed for full-time entertainment and enthusiasms. It \nteaches the Gamer to bealert at every situation he/she faces, because if \nthe Gamer is not fully alert and notice the saucerfire he/she must be hit",
    "by the saucer-bombs. Though the proposed game is an action game, it \ndoesn’t involve direct violence. No zombie killing, animal killing, or \nhuman killing is performed in the game. So it can also be viewed as a \nnon-violence game. Kids can also play this game, because the design of \nthe game is very simple, controlling the gameis very easy – pressing \nsome neighboring keys of the keyboard",
    "Strategy/Algorithm Used in Code \nThe highest-priority and the lowest-priority rules seemed obvious to me \nright  away.The highest-priority are these: \n1. If I can win on this move,do it. \n2. If the other player can win on the next move,block thatwinning square.Here \nare the lowest-priority rules,used only if there isnothing suggested more \nstrongly by the board position: \nn-2. Take the center square if it’s free. \nn-1. Take a corner square if one is free. \nn. Take whatever is available.",
    "n. Take whatever is available. \nThe highest priority rules are the ones dealing with themost urgent \nsituations:either I or my opponent can win onthe next move.The lowest priority \nones deal with the leasturgent situations,in which there is nothing special \naboutthe moves already made to guide me.What was harder was to find the \nrules in between.I knewthat the goal of my own tic-tac-toe strategy was to set \nup afork, a board position in which I have two winningmoves, so my opponent",
    "can only block one of them. \nHere is an example: \n \nX 0  \n \nX  \nX  \n0 \nX can win by playing in square 3 orsquare 4. It’s O’s turn,but poor O can only block \none of those squares at a time. Whichever O picks, X will then win by picking the \nother one. Given this concept of forking, I decided to use it asthe next highest \npriority rule:3. If I can make a move that will set up a fork for myself, do it.That was \nthe end of the easy part. My first attempt at writing the program used only these",
    "six rules. Unfortunately, it lost in many different situations. Ineeded to add \nsomething, but I had trouble finding a goodrule to add. My first idea was that rule 4 \nshould be the defensive equivalent of rule 3, just as rule 2 is the defensive \nequivalent of rule 1:4a. If, on the next move, my opponent can set up a fork,block \nthat possibility by moving into the square thatis common to his two winning \ncombinations. \nIn other words, apply the same search technique to the opponent’s position",
    "that I applied to my own.Thisstrategy works well in many cases, but not all. \nForexample, here is a sequence of moves under thisstrategy,with the human \nplayer moving first:",
    "In the fourth grid, the computer (playing O) has discovered that X can set up a \nfork by moving in square 6, between the winning combinations 456and 369. \nThe computer moves to block this fork.Unfortunately,X can also set up a fork by \nmoving in squares 3, 7, or 8. The computer’s move in square 6 has blocked one \ncombination of the square-3 fork,but X can still set up the other two. In the fifth \ngrid, X has moved in square 8. This sets up the winning combinations 258",
    "and789.The computer can only block one of these, and X will win on the next \nmove. Since X has so many forks available, does this mean that the game was \nalready hopeless before O moved in square6? No. Here is something O could \nhave done: \n \n \n \n \n \n \n \n \n \nX  \n \n \n \n \n0 \n \n \n \nX \n \n \n \n \n \n0 \n \n \n \nX \n \n \n \nX \n \n0  \n0 \n \nX  \n \n \nX \n \n0 \nX \n0 \n \nX \n \n \n \nX \n \n \n \n \n \nX \n \n \n \n \n \n0 \n \n \n \nX \n \n \n \n \n \n0 \n \n \n \nX \n \n \n \nX \n \n0 \n \n \n \nX \n \n0 \n \nX \n \n0 \n \n \nX \nX \n \nX \n \nX \n \n0 \n \n \nX \nX \n0 \n0",
    "0 \n \n \nX \nX \n \nX \n \nX \n \n0 \n \n \nX \nX \n0 \n0 \n \nX",
    "In this sequence, the computer’s second move is in square7. This move also \nblocks a fork, but it wasn’t chosen for that reason. Instead, it was chosen to \nforce X’s next move. In the fifth grid, X has had to move in square 4, to prevent \nan immediate win by O. The advantage of this situation for O is that square 4 \nwas not one of the ones with which X could set up a fork. O’s next move, in the \nsixth grid, is also forced. But by then the board is too crowded for either player",
    "to force a win; the game ends in a tie, as usual. This analysis suggests a different \nchoice for an intermediate-level strategy rule, taking the offensive:4b.If I can \nmake a move that will set up a winning combination for myself, do it. Compared \nto my earlier try, this rule has the benefit of simplicity. It’s much easier for the \nprogram to look for a single winning combination than for a fork, which is two \nsuch combinations with a common square.",
    "such combinations with a common square. \nUnfortunately, this simple rule isn’t quite good enough. In the example just \nabove ,the computer found the winning combination in which it already had \nsquare 1,and the other two were free. But why should it choose to move in \nsquare 7 rather than square 4? If the program did choose square 4, then X’s \nmove would still be forced, into square7. We would then have forced X into",
    "creating a fork, which would defeat the program on the next move. It seems that \nthere is no choice but to combine the ideas from rules 4a and 4b:4. If I can make \na move that will set up a winning combination for myself, do it. But ensure that \nthis move does not force the opponent into establishing a fork. \nWhat this means is that we are looking for a winning combination in which the \ncomputer already owns one square and the other two are empty. Having found",
    "such a combination, we can move in either of its empty squares. Whichever we \nchoose, the opponent will be forced to choose the other one on the next move. \nIf one of the two empty squares would create a fork for the opponent, then the \ncomputer must choose that square and leave the other for the opponent. What if \nboth of the empty squares in the combination we find would make forks for the \nopponent? In that case, we’ve chosen a bad winning combination. It turns out",
    "thatthere is only one situation in which this can happen: \n \n \n \nX  \n \n \n0 \n \n \n \nX \nX  \n \n \n \n \n \n \n \n \nX  \n \n \n0",
    "Again, the computer is playing O. After the third grid, it is looking for a possible \nwinning combination for itself. There are three possibilities: 258,357 and 456. \nSo far we have not given the computer any reason to prefer one over another. \nBut here is what happens if the program happens to choose 357: \n \n \n \n \nX \n \n0 \n \n0 \n \nX \n \nX \n \nBy this choice, the computer has forced its opponent into a fork that will win \nthe game for the opponent. If the computer chooses either of the other two",
    "possible winning combinations, the game ends in a tie. (All moves after this \nchoice turn out to be forced.)This particular game sequence was very \ntroublesome form me because it goes against most of the rules I had chosen \nearlier. For one thing, the correct choice for the program is any edge square, \nwhile the corner squares must be avoided. This is the opposite of the usual \npriority. Another point is that this situation contradicts rule 4a(prevent forks for",
    "the other player) even more sharply than the example we considered earlier. In \nthat example, rule 4a wasn’t enough guidance to ensure a correct choice, but \nthe correct choice was at least with the rule. That is, just blocking a fork isn’t \nenough, but threatening a win and blocking a fork is better than just \nthreatening a win alone. This is the meaning of rule 4. But in this new situation, \nthe corner square (the move we have to avoid) block a fork, while the edge",
    "square (the correct move) block a fork! When I discovered this anomalous case, \nI was ready to give up on the idea of beautiful, general rules. I almost decided \nto build into the program a special check for this precise board configuration. \nThat would have been pretty ugly, I think. But a shift in viewpoint makes this \ncase easier to understand: What the program must do is force the other \nplayer’s move, and force it in a way that helps the computer win. If one possible \nX",
    "X \n \n \n \n \n \n \n \n \n \nX \n \n \n \n0 \n \n \n \n \n \nX  \n \n \n0 \n \n \n \nX \n \nX \n \n0 \n \n0 \n \n \n \nX",
    "winning combination doesn’t allow us to meet these conditions, the program \nshould try another combination. My mistake was to thinkeither about forcing \nalone (rule 4b) or about the opponent’s forks alone (rule 4a). As it turns out, \nthe board situation we’ve been considering is the only one in which a possible \nwinning combination could include two possible forks for the opponent. What’s \nmore, in this board situation, it’s a diagonal combination that gets us in trouble,",
    "while a horizontal or verticalcombination is always okay. Therefore, I was able \ntoimplement rule 4 in a way that only considers one possible winning \ncombination by setting up the program’s data structures so that diagonal \ncombinations are the last to be chosen. This trick makes the program’s design \nless than obvious from reading the actual program, but it does save the \nprogram some effort. \n \nDFS(Depth First Search)Algorithm: \nStep 1: SET STATUS = 1 (ready state) for each node in G",
    "Step 2: Push the starting node A on the stack and set its STATUS = 2 (waiting \nstate) \nStep 3: Repeat Steps 4 and 5 until STACK is empty \nStep 4: Pop the top node N. Process it and set its STATUS = 3 (processed state) \nStep 5: Push on the stack all the neighbors of N that are in the ready state \n(whose STATUS = 1) and set their STATUS = 2 (waiting state) \n[END OF LOOP] \nStep 6: EXIT \nPseudocode: \nDFS(G,v) ( v is the vertex where the search starts ) \nStack S := {}; ( start with an empty stack )",
    "Stack S := {}; ( start with an empty stack ) \nfor each vertex u, set visited[u] := false; \npush S, v; \nwhile (S is not empty) do \nu := pop S; \nif (not visited[u]) then",
    "visited[u] := true; \nfor each unvisited neighbour w of uu \npush S, w; \nend if \nend while \nEND DFS() \n \nSource Code: \n \n#include <stdio.h> \n#include <conio.h> \n \nchar square[10] = { 'o', '1', '2', '3', '4', '5', '6', '7', '8', '9' }; \n \nint checkwin(); \nvoid board(); \n \nint main() \n{ \n    int player = 1, i, choice; \n \n    char mark; \n    do \n    { \n        board(); \n        player = (player % 2) ? 1 : 2; \n \n        printf(\"Player %d, enter a number:  \", player);",
    "scanf(\"%d\", &choice); \n \n        mark = (player == 1) ? 'X' : 'O'; \n \n        if (choice == 1 && square[1] == '1') \n            square[1] = mark; \n             \n        else if (choice == 2 && square[2] == '2') \n            square[2] = mark; \n             \n        else if (choice == 3 && square[3] == '3') \n            square[3] = mark;",
    "else if (choice == 4 && square[4] == '4') \n            square[4] = mark; \n             \n        else if (choice == 5 && square[5] == '5') \n            square[5] = mark; \n             \n        else if (choice == 6 && square[6] == '6') \n            square[6] = mark; \n             \n        else if (choice == 7 && square[7] == '7') \n            square[7] = mark; \n             \n        else if (choice == 8 && square[8] == '8') \n            square[8] = mark;",
    "square[8] = mark; \n             \n        else if (choice == 9 && square[9] == '9') \n            square[9] = mark; \n             \n        else \n        { \n            printf(\"Invalid move \"); \n \n            player--; \n            getch(); \n        } \n        i = checkwin(); \n \n        player++; \n    }while (i ==  - 1); \n     \n    board(); \n     \n    if (i == 1) \n        printf(\"==>\\aPlayer %d win \", --player); \n    else \n        printf(\"==>\\aGame draw\"); \n \n    getch();",
    "getch(); \n \n    return 0; \n} \n \nint checkwin() \n{ \n    if (square[1] == square[2] && square[2] == square[3]) \n        return 1;",
    "else if (square[4] == square[5] && square[5] == square[6]) \n        return 1; \n         \n    else if (square[7] == square[8] && square[8] == square[9]) \n        return 1; \n         \n    else if (square[1] == square[4] && square[4] == square[7]) \n        return 1; \n         \n    else if (square[2] == square[5] && square[5] == square[8]) \n        return 1; \n         \n    else if (square[3] == square[6] && square[6] == square[9]) \n        return 1;",
    "return 1; \n         \n    else if (square[1] == square[5] && square[5] == square[9]) \n        return 1; \n         \n    else if (square[3] == square[5] && square[5] == square[7]) \n        return 1; \n         \n    else if (square[1] != '1' && square[2] != '2' && square[3] != '3' && \n        square[4] != '4' && square[5] != '5' && square[6] != '6' && square[7]  \n        != '7' && square[8] != '8' && square[9] != '9') \n \n        return 0; \n    else \n        return  - 1; \n} \n \nvoid board()",
    "return  - 1; \n} \n \nvoid board() \n{ \n    //system(\"cls\"); \n    printf(\"\\n\\n\\tTic Tac Toe\\n\\n\"); \n \n    printf(\"Player 1 (X)  -  Player 2 (O)\\n\\n\\n\"); \n \n \n    printf(\"     |     |     \\n\"); \n    printf(\"  %c  |  %c  |  %c \\n\", square[1], square[2], square[3]); \n \n    printf(\"__|_|__\\n\"); \n    printf(\"     |     |     \\n\"); \n \n    printf(\"  %c  |  %c  |  %c \\n\", square[4], square[5], square[6]);",
    "printf(\"__|_|__\\n\"); \n    printf(\"     |     |     \\n\"); \n \n    printf(\"  %c  |  %c  |  %c \\n\", square[7], square[8], square[9]); \n \n    printf(\"     |     |     \\n\\n\"); \n} \n \nOutput:",
    "Conclusion: \n \nThe Tic Tac Toe game is most familiar among all the age groups. \nIntelligence can be a property of any purpose-driven decision maker. \nThis basic idea has been suggested many times. An algorithm of \nplaying Tic Tac Toe has been presented and tested that works in \nefficient way. Overall the system works without any bugs."
  ],
  "created_at": "2025-09-21 14:22:53.236781"
}